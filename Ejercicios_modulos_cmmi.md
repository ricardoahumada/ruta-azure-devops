# Ejercicios Finales por Módulo (Actualizados – Proyecto **CMMI** + App “TaskFlow”)

| **Módulo** | **Ejercicio Final** |
|-----------|------------------------------|
| **1. Introducción a Azure DevOps** | **Ejercicio: Configuración inicial del entorno para “TaskFlow” con plantilla CMMI**<br><br>**Contexto**: Tu equipo va a desarrollar *TaskFlow*, una app de gestión de tareas, siguiendo prácticas de ingeniería de software definidas en el modelo CMMI.<br><br>**Pasos**:<br>1. Crea una **organización** en Azure DevOps (ej.: `taskflow-dev`).<br>2. Crea un **proyecto nuevo** llamado **TaskFlow**, usando la **plantilla CMMI**.<br>3. Invita a un compañero (o usa una cuenta secundaria) como **usuario externo** con licencia **Basic**.<br>4. Configura la integración con tu **cuenta Microsoft o Azure AD** (si aplica).<br>5. Navega por las 5 herramientas: Boards (backlog vacío con tipos CMMI), Repos (repo `TaskFlow` creado), Pipelines (sin pipelines), Test Plans, Artifacts.<br>6. Instala una extensión útil desde Marketplace (ej.: **“Azure DevOps CLI”** o **“Markdown Viewer”**).<br>7. Verifica en **Project Settings > Overview** que el proceso es **CMMI**.<br><br>**Resultado esperado**: Proyecto *TaskFlow* listo, con plantilla CMMI, usuario invitado y entorno explorado. |
| **2. Planificación con Azure Boards (CMMI)** | **Ejercicio: Construir el backlog de requisitos de “TaskFlow” y personalizar el flujo de trabajo CMMI**<br><br>**Contexto**: El analista de requisitos debe documentar y estructurar las funcionalidades iniciales de *TaskFlow* siguiendo buenas prácticas CMMI.<br><br>**Pasos**:<br>1. Crea la siguiente jerarquía en **Boards**:<br>   - **Epic**: “MVP de TaskFlow”<br>   - **Feature**: “Gestión de Tareas”<br>   - **Requisitos** (4 total):<br>     • “El sistema debe permitir el registro e inicio de sesión de usuarios”<br>     • “El sistema debe mostrar las tareas pendientes del usuario”<br>     • “El sistema debe permitir crear nuevas tareas”<br>     • “El sistema debe permitir marcar tareas como completadas”<br>   - Crea **2–3 Tareas** por Requisito (ej.: “Diseñar interfaz”, “Implementar API REST”, “Escribir casos de prueba”).<br>2. Personaliza el proceso CMMI:<br>   - Añade un campo personalizado **“Prioridad de Requisito”** (Alta/Media/Baja) a los work items de tipo **Requirement**.<br>   - Añade un estado **“En Revisión”** al flujo de **Requirement** (entre *Active* y *Closed*).<br>3. Crea un **tablero Kanban** con columnas: *Proposed → Active → En Revisión → Closed*.<br>4. Aplica un **WIP Limit = 2** en la columna *Active*.<br>5. Etiqueta los requisitos con **“Frontend”** o **“Backend”**.<br>6. Guarda una **plantilla de Requirement** para futuros requisitos.<br><br>**Resultado esperado**: Backlog de requisitos estructurado para *TaskFlow*, con flujo personalizado y tablero Kanban funcional. |
| **3. Optimización de sprints y colaboración en equipos CMMI** | **Ejercicio: Planificar y monitorear la Iteración 1 de “TaskFlow”**<br><br>**Contexto**: El equipo inicia el desarrollo del MVP bajo un enfoque iterativo compatible con CMMI. Debes planificar la primera iteración y configurar métricas de seguimiento.<br><br>**Pasos**:<br>1. Crea un **equipo** llamado **“TaskFlow Core”** y asígnalo al área raíz del proyecto.<br>2. Define la **capacidad del equipo** para la **Iteración 1** (ej.: 2 miembros × 6h/día × 5 días = 60h).<br>3. Asigna a la **Iteración 1** los siguientes **Requisitos**:<br>   - “Mostrar tareas pendientes”<br>   - “Crear nueva tarea”<br>   - “Marcar tarea como completada”<br>4. Asigna **Tareas** a los miembros del equipo (usa nombres reales o ficticios como “Dev1”, “Dev2”).<br>5. Simula progreso: mueve 2 requisitos a *Active* y 1 a *Closed*.<br>6. Crea un **dashboard** con widgets:<br>   - Burndown Chart de la Iteración 1<br>   - Query-based: “Requisitos en Iteración 1 por estado”<br>   - Cumulative Flow Diagram<br>7. Configura una **notificación en Microsoft Teams** (usando Power Automate o webhook) que se active al cerrar un requisito (*Closed*).<br><br>**Resultado esperado**: Iteración 1 planificada, capacidad definida, dashboard de seguimiento y notificación en Teams. |
| **4.1. Gestión de código fuente y colaboración con Azure Repos (CMMI)** | **Ejercicio: Configurar ramas, políticas de PR y trazabilidad con requisitos**<br><br>**Contexto**: El equipo debe establecer prácticas seguras de control de versiones alineadas con CMMI, garantizando revisión de código y trazabilidad.<br><br>**Pasos**:<br>1. En el repositorio **TaskFlow**, crea una estructura básica de proyecto (Node.js o .NET):<br>   - `src/`, `tests/`, `package.json` o `.csproj`.<br>2. Crea una rama **`develop`** como rama principal de integración.<br>3. Protege las ramas **`main`** y **`develop`** con políticas:<br>   - Requiere **Pull Request**<br>   - Requiere **al menos 1 aprobación**<br>   - Requiere **comentarios resueltos**<br>   - Requiere **vinculación con work item**<br>4. Crea una rama de funcionalidad (ej.: `feature/lista-tareas`) y haz un **commit** que incluya el ID de un **Requisito** (ej.: `AB#12`).<br>5. Abre un **Pull Request** desde `feature/lista-tareas` hacia `develop`.<br>6. Simula revisión: añade comentarios, resuélvelos y aprueba el PR.<br>7. Verifica en el work item del requisito que aparece el enlace al PR y al commit.<br><br>**Resultado esperado**: Flujo de ramas definido, políticas de PR activas, y trazabilidad entre código y requisitos CMMI. |
| **4.2. Integración continua (CI) con Azure Pipelines** | **Ejercicio: Automatizar pruebas y validación en cada Pull Request**<br><br>**Contexto**: Cada cambio de código debe validarse automáticamente para garantizar calidad y cumplimiento con los requisitos CMMI.<br><br>**Pasos**:<br>1. Crea un archivo **`azure-pipelines.yml`** en la raíz del repositorio.<br>2. Configura el pipeline para que se ejecute en **todo PR a `develop` o `main`**.<br>3. El pipeline debe:<br>   - Usar una máquina de agente compatible (Ubuntu, Windows, etc.)<br>   - Instalar dependencias (`npm install` o `dotnet restore`)<br>   - Ejecutar pruebas unitarias (`npm test` o `dotnet test`)<br>   - Publicar resultados de pruebas en Azure DevOps<br>   - Publicar cobertura de código (opcional)<br>4. Asegúrate de que el **estado del pipeline se requiera** en las políticas de rama (paso 3 del ejercicio 4.1).<br>5. Simula un fallo de prueba y verifica que el PR **no se pueda completar**.<br>6. (Opcional) Usa **Webhook.site** para enviar una notificación HTTP con el resultado del pipeline.<br><br>**Resultado esperado**: Pipeline de CI funcional que bloquea merges si las pruebas fallan, con visibilidad en PRs y trazabilidad con requisitos. |
| **4.3. Entrega continua (CD) y publicación con Azure Pipelines** | **Ejercicio: Automatizar empaquetado, publicación y despliegue del artefacto**<br><br>**Contexto**: Al fusionar en `main`, el sistema debe generar un artefacto listo para pruebas o producción, manteniendo trazabilidad CMMI.<br><br>**Pasos**:<br>1. Modifica o crea un pipeline que se active **solo al hacer push a `main`**.<br>2. El pipeline debe:<br>   - Ejecutar nuevamente las pruebas (como en CI)<br>   - Generar un **artefacto empaquetado** (ej.: `.zip`, `.nupkg`, o imagen Docker)<br>   - Publicar el artefacto en un **feed de Azure Artifacts** llamado `taskflow-packages`<br>3. Crea un **stage de despliegue** (Deployment Job) que simule un entorno (ej.: “QA” o “Staging”):<br>   - Usa un **Environment** en Pipelines<br>   - Registra el despliegue en la pestaña **Environments**<br>4. Vincula el artefacto publicado al **Requisito** correspondiente (mediante ID en commit o mediante enlace manual en el work item).<br>5. (Opcional) Configura una **aprobación manual** antes de desplegar a “Producción”.<br>6. Verifica en **Artifacts** y **Environments** que todo el flujo se registró correctamente.<br><br>**Resultado esperado**: Pipeline de CD que genera, publica y registra despliegues de artefactos, con trazabilidad completa hacia los requisitos CMMI. |
